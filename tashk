#!/bin/sh
# (c) Rudy Dellomas III, GPLv3. See LICENSE file at root of repository.

[ -z "$TASHK_DIR" ] && echo 'Please set TASHK_DIR.' >&2 && exit 1
[ "$(id -u)" = "root" ] && echo 'Running this as root is a bad idea!' >&2 && exit 1

_git() {
	# drop-in git replacement
	# TODO: check if the directory contains a git repository...
	if [ "$TASHK_SILENCE_GIT" = "false" ]; then
		git -C "$TASHK_DIR" "$@"
	else
		# S I L E N C E, G I T - Orks, probably
		git -C "$TASHK_DIR" "$@" >/dev/null 2>&1
	fi
}

toggle_silent() {
	if [ "$TASHK_SILENCE_GIT" = "false" ]; then
		TASHK_SILENCE_GIT="true"
	else
		TASHK_SILENCE_GIT="false"
	fi
}

tashk_add() {
	[ -n "$ISODATE" ] && datemsg=" (Date will be entered automatically.)"
	echo "Enter the new task.$datemsg" >&2

	read -r task
	if [ -z "$task" ]; then
		echo "No task entered, aborting..." >&2
		return 2
	fi
	# TODO: add ability to toggle priority + date handling with flags
	priority=$(echo "$task" | grep '^([A-Z])')
	if [ -n "$priority" ]; then
		priority="${priority%% *} "
		echo "Detected priority: $priority" >&2
		task="${task##"$priority"}"
	fi
	# TODO: check if the user gave a date?
	if [ -n "$ISODATE" ]; then
		task="$priority$ISODATE $task"
	else
		task="$priority$task"
	fi

	echo "$task" >> "$FILE"
	task_no=$(wc -l "$FILE")
	task_no=${task_no%%" $FILE"}
	echo "Added \"$task\" as task no. $task_no" >&2
	_git commit -m "\"$task\" (no. $task_no) added to $TASHK_FILE" "$FILE"
}

tashk_clean() {
	to_delete=$(grep -c '^x ' "$FILE")
	to_compress=$(grep -c '^$' "$FILE")
	[ "$to_delete" -eq 0 ] && [ "$to_compress" -eq 0 ] && echo "Nothing to clean up." >&2 && return 2
	# TODO: this would be a nice little safety
#	if [ -z $force ]; then
#		echo "Really delete $to_delete completed task(s)? (y/N)"
#	fi
	# XXX: -i~ is a common extension, but is non-POSIX.
	# Using it here would save a `cp`.
	cp "$FILE" "$FILE~"
	sed '/^x /d;/^$/d' "$FILE~" > "$FILE"
	echo "$to_delete task(s) and $to_compress empty lines deleted from $TASHK_FILE."
	_git commit -m "Removed $to_delete completed tasks, $to_compress empty lines from $TASHK_FILE" "$FILE"
}

tashk_do() {
	# Mark task as completed.
	task_no=$2
	task=$(sed "$task_no!d" "$FILE")
	[ "${task%% *}" = "x" ] && echo "Can't do a done task!" && return 1

	# TODO: add a way of disabling adding the date?
	taskdone=$(echo "$task" | sed "\
		s/^(\([A-Z]\)) \(.*\)/\2 pri:\1/;\
		s/^\(.*\)/x $ISODATE \1/;")

	cp "$FILE" "$FILE~"
	sed "$task_no c\
		$taskdone" "$FILE~" > "$FILE"

	fail=$?
	if [ "$fail" -ne 0 ]; then
		cp "$FILE~" "$FILE"
		echo "ERROR: sed failed with error code $fail" >&2
		return $fail
	fi
	_git commit -m "Marked task $task_no as complete - $taskdone" "$FILE"
}

tashk_ls() {
	# opts: -p: prefilter through command
	shift 1
	parg=''; pflag='0' # set defaults
	COMMAND_FLAGS='p:'
	tashk_getopts "$@"
	[ -n "$parg" ] && TASHK_LS_PREFILTER="$parg" # "$TASHK_LS_PREFILTER" can be set to a default

	echo "$pflag"
	if [ -z "$TASHK_LS_PREFILTER" ]; then
		nl -ba -w2 -s' ' "$FILE"
	else
		$TASHK_LS_PREFILTER < "$FILE" | nl -ba -w2 -s' '
	fi

}

tashk_edit() {
	# open in editor. vi if unspecified.
	EDITOR="${EDITOR:-vi}"
	$EDITOR "$FILE"
	_git commit -m "tashk edit on $TASHK_FILE" "$FILE"
}

tashk_sort() {
	# The todo.txt file standard's rationale for sorting
	# is only correct when characters are sorted in ASCII/UTF8 order.
	# Annoyingly, POSIX sort requires that it changes sort behaviour based on locale.
	# Even in English locales (e.g. en_AU, en_US), they sort Numbers->Letters->Symbols,
	# Rather than the sane default of ASCII/UTF8 character set order.
	# (most) ASCII Symbols -> Numbers -> Letters
	LC_ALL=POSIX sort "$FILE" -o "$FILE"
	_git commit -m "Sorted $TASHK_FILE" "$FILE"
}

tashk_usage() {
	case "$1" in
		add|a)
			echo "Unimplemented." >&2;;
		edit|e)
			echo \
"Edits todo.txt in your favourite terminal editor.
Uses \$EDITOR, or vi if unset." >&2 ;;
		clean|c)
			echo \
"Deletes completed tasks and empty lines from the todofile
Stores a 'backup' in $TASHK_FILE~, but this will get
overwritten by the next operation." >&2;;
		do|d|x)
			echo "Unimplemented." >&2;;
		rm|remove)
			echo "Unimplemented." >&2;;
		ls|list|show)
			echo \
"Usage: $PROGRAM ls [-p prefilter]
	Lists tasks using command 'nl(1p)'.

FLAGS:
	'-p prefilter' - Passes $TASHK_FILE through the stdin of the command
			 'prefilter' before passing the output to nl(1p).
			 The latest invocation will be the one used.

ENVIRONMENT VARIABLES:
	\$TASHK_LS_PREFILTER can be used to set a default prefilter even
	when the -p flag is not set." >&2;;
		init)
			echo "Unimplemented." >&2;;
		git)
			echo "Runs git and passes all arguments to it verbatim." >&2;;
		*)
			echo \
"tashk: the unix todo.txt manager
Usage: $PROGRAM [-v] [-f todofile] [command] [command_flags] command_args...
  '-v' toggles git output (supressed by default)
  '-f todofile' indicates which todo file to use, default todo.txt
Command flags are command-specific, but always stop at the first non-flag argument.

Command must be one of the following:
	add: Read and add a new task from stdin
	clean: Delete all completed tasks (creates backup)
	edit: Edit todofile in text editor
	do: Mark a task as complete (creates backup)
	remove: Delete a task (creates backup)
	ls: List all tasks, with numbers
	init: ???
	sort: sort by character set (i.e. Priority items first, done items last)
	git: Call 'git' from within \$TASHK_DIR and always print output
	help: display this usage message
Commands marked 'creates backup' copies the todofile to '\$TASHK_DIR/todofile~',
overwriting anything that was already there (i.e. older backups).
For help with specific commands, do 'tashk help <command>'" >&2;;
	esac
}

#shellcheck disable=2034
tashk_getopts() {
	# Set variables based on flags given
	# "$COMMAND_FLAGS" should be set to a valid getopts string
	# v and f: are always valid and reset whatever the default was

	# Arguments that aren't v: or :f are handled as follows.
	# Their presence is stored in a variable known as $xflag,
	# where x is the character of that flag. Repeated invocations will
	# toggle $xflag between 1 and 0, with 1 meaning an odd total of invocations.
	# This allows for the "toggling" of a default flag by simply invoking it again.

	# If the flag takes a particular argument, it will be stored in $xarg.
	# $xarg will *always be empty* if not configured to take an argument.
	while getopts "vf:$COMMAND_FLAGS" flag; do
		case "$flag" in
			#a) aflag=1; aarg="$OPTARG" ;;
			v) toggle_silent;;
			f) TASHK_FILE=$OPTARG;;
			p) [ "$pflag" != '0' ]; pflag=$?; parg=$OPTARG;;
			?) tashk_usage "$COMMAND"; exit 2;;
		esac
		OPTARG=""
	done
	FILE="$TASHK_DIR/$TASHK_FILE"
}


PROGRAM=${0##*/}

# Quit if we don't have any arguments
[ "$#" -lt 1 ] && tashk_usage && exit 2

# Get options that will apply by default
tashk_getopts "$@"
shift $(( OPTIND - 1 ))
COMMAND=$1

# Set Defaults
ISODATE=$(date '+%Y-%m-%d') # ISO standard date format, used by the format
TASHK_SILENCE_GIT=${TASHK_SILENCE_GIT:-true}
TASHK_FILE="${TASHK_FILE:-todo.txt}" # The name of the file - todo.txt by default
FILE="$TASHK_DIR/$TASHK_FILE" # The absolute path of the file

# TODO: Add a _git pull here
case "$COMMAND" in
	add|a) tashk_add "$@";;
	clean|c) tashk_clean "$@";;
	edit|e) tashk_edit "$@";;
	do|x|d) tashk_do "$@";;
	rm|remove) ;;
	ls|list|show) tashk_ls "$@";;
	init);;
	sort|s) tashk_sort "$@";;
	git) TASHK_SILENCE_GIT=false && shift 1 && _git "$@";;
	help) tashk_usage "$2";;
	*) tashk_usage help;;
esac
